template<class T>
struct Polynomial:vector<T>{
	using vector<T>::vector;
	Polynomial& operator+=(const Polynomial &x){
		if((*this).size()<x.size())(*this).resize(x.size());
		for(int i=0;i<x.size();i++)(*this)[i]+=x[i];
		return *this;
	}
	Polynomial& operator-=(const Polynomial &x){
		if((*this).size()<x.size())(*this).resize(x.size());
		for(int i=0;i<x.size();i++)(*this).operator[](i)-=x[i];
		return *this;
	}
	Polynomial& operator*=(const Polynomial &x){
		if((*this).size()==0||x.size()==0){
			(*this).clear();
			return *this;
		}
		Polynomial z((*this).size()+x.size()-1);
		for(int i=0;i<(*this).size();i++){
			for(int j=0;j<x.size();j++){
				z[i+j]+=(*this).operator[](i)*x[j];
			}
		}
		return *this=z;
	}
	Polynomial& operator+=(const T &x){
		if((*this).size()==0)(*this).resize(1);
		(*this).operator[](0)+=x;
		return *this;
	}
	Polynomial& operator-=(const T &x){
		if((*this).size()==0)(*this).resize(1);
		(*this).operator[](0)-=x;
		return *this;
	}
	Polynomial& operator*=(const T &x){
		for(int i=0;i<(*this).size();i++)(*this).operator[](i)*=x;
		return *this;
	}
	Polynomial& operator/=(const T &x){
		for(int i=0;i<(*this).size();i++)(*this).operator[](i)/=x;
		return *this;
	}
	
	Polynomial operator+(const Polynomial &x)const{
		return Polynomial(*this)+=x;
	}
	Polynomial operator-(const Polynomial &x)const{
		return Polynomial(*this)-=x;
	}
	Polynomial operator*(const Polynomial &x)const{
		return Polynomial(*this)*=x;
	}
	Polynomial operator+(const T &x)const{
		return Polynomial(*this)+=x;
	}
	Polynomial operator-(const T &x)const{
		return Polynomial(*this)-=x;
	}
	Polynomial operator*(const T &x)const{
		return Polynomial(*this)*=x;
	}
	Polynomial operator/(const T &x)const{
		return Polynomial(*this)/=x;
	}
	
	T eval(T x){
		T ret=0;
		T powX=1;
		for(int i=0;i<(*this).size();i++){
			ret+=(*this).operator[](i)*powX;
			powX*=x;
		}
		return ret;
	}
};
template<class T>
Polynomial<T>simpleInterpolate(vector<T>x,vector<T>y){
	Polynomial<T>ret;
	for(int i=0;i<x.size();i++){
		Polynomial<T>prod={1};
		T div=1;
		for(int j=0;j<x.size();j++)if(i!=j){
			div*=x[i]-x[j];
			Polynomial<T>tmp={-x[j],1};
			prod*=tmp;
		}
		ret+=prod*y[i]/div;
	}
	return ret;
}

using poly=Polynomial<mint>;




int N,T;
int X[55],Y[55];

mint calcNumCovered(int t){
	vint ys;
	rep(i,N){
		ys.pb(Y[i]-t);
		ys.pb(Y[i]+t+1);
	}
	sort(all(ys));
	ys.erase(unique(all(ys)),ys.end());

	vector<pint>qs;
	rep(i,N){
		qs.pb({X[i]-t,i*2});
		qs.pb({X[i]+t+1,i*2+1});
	}
	sort(all(qs));
	int lastX=0;
	
	mint ret=0;
	vint num(ys.size());
	rep(i,qs.size()){
		int x=qs[i].fi;
		int k=qs[i].se/2;
		
		int sum=0;
		for(int j=0;j+1<ys.size();j++)if(num[j])sum+=ys[j+1]-ys[j];
		ret+=mint(sum)*(x-lastX);
		lastX=x;

		int l=lower_bound(all(ys),Y[k]-t)-ys.begin();
		int r=lower_bound(all(ys),Y[k]+t+1)-ys.begin();
		int coef;
		if(qs[i].se&1)coef=-1;
		else coef=1;
		for(int j=l;j<r;j++)num[j]+=coef;
	}
	return ret;
}
